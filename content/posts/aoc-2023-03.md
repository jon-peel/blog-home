+++
title = ":star: AoC 2023, Day 3, Gear Ratios"
author = ["Jonathan Peel"]
date = 2023-12-04T08:38:00+03:00
tags = ["blog", "AoC", "advent", "code", "fsharp"]
draft = false
+++

Today's puzzle is called [Gear Ratios](https://adventofcode.com/2023/day/3).


## Part 1 {#part-1}

I am going to start by declaring a couple of types to help me.
A digit can be a `SymboolDigit` or a `NonSymbolDigit`, where a `SymbolDigit` will be any digit with a symbol around it.

{{< highlight fsharp >}}
open System

type Digit = SymbolDigit of char | NonSymbolDigit of char
type Number = PartNumber of string | OtherNumber of string
{{< /highlight >}}

I also want a few helper functions. <br />
Check if a character is a symbol (not a digit or dot).

{{< highlight fsharp >}}
let isSymbol chr = chr <> '.' && not (Char.IsDigit chr)
{{< /highlight >}}

Also, need to check if the edges are symbols, so lets have a way of getting all edges for a particular point.

{{< highlight fsharp >}}
let getEdges (text: string[]) r c =
    seq { if r > 0 && c > 0 then yield (r-1, c-1)
          if r > 0 then yield (r-1, c)
          if r > 0 && c < text.[r-1].Length - 1 then yield (r-1, c+1)
          if c > 0 then yield (r, c-1)
          if c < text.[r].Length - 1 then yield (r, c+1)
          if r < text.Length - 1 && c > 0 then yield (r+1, c-1)
          if r < text.Length - 1 then yield (r+1, c)
          if r < text.Length - 1 && c < text.[r+1].Length - 1 then yield (r+1, c+1) }
{{< /highlight >}}

Also, if there is a symbol on the edge make it a `SymbolDigit`, or else make it a `NonSymbolDigit`.

{{< highlight fsharp >}}
let asDigit text r c chr =
    let hasSymbol =
        getEdges text r c
        |> Seq.map (fun (r, c) -> text[r][c])
        |> Seq.exists isSymbol
    if hasSymbol then SymbolDigit chr
    else NonSymbolDigit chr
{{< /highlight >}}

I think that is the main helper functions done, So I want the main function to extract the digit groups. This uses an inner recursive function.

{{< highlight fsharp >}}
let extract (text: string[]) =
    let rec extractRow r c (acc: List<Digit list>) (num: Digit list): List<Digit list> =
        if r >= text.Length then acc
        else if (c >= text[r].Length && num = []) then extractRow (r+1) 0 acc []
        else if (c >= text[r].Length) then extractRow (r+1) 0 (acc@[num]) []
        else
            let chr = text[r][c]
            if Char.IsDigit(chr) then
                let dig = asDigit text r c chr
                extractRow r (c+1) acc (num@[dig])
            else if num <> [] then
                extractRow r (c+1) (acc@[num]) []
            else extractRow r (c+1) acc []
    extractRow 0 0 [] []
{{< /highlight >}}

This will result in a list of `Digit` lists, so lets have a function that will convert a digit list into a `PartNumber` or `OtherNumber`.

{{< highlight fsharp >}}
let asNumber (num: Digit list) =
    let rec partial (acc: Number) (remain: Digit list): Number =
        match remain, acc with
        | [], _ -> acc
        | SymbolDigit head::tail, PartNumber x -> partial (PartNumber $"{x}{head}") tail
        | SymbolDigit head::tail, OtherNumber x -> partial (PartNumber $"{x}{head}") tail
        | NonSymbolDigit head::tail, PartNumber x -> partial (PartNumber $"{x}{head}") tail
        | NonSymbolDigit head::tail, OtherNumber x -> partial (OtherNumber $"{x}{head}") tail
    partial (OtherNumber "") num
{{< /highlight >}}

And finally, lets convert the `PartNumber` into integers and ignore the `OtherNumber`.

{{< highlight fsharp >}}
let partNumberAsInt (number: Number) =
    match number with
    | PartNumber x -> Some (int x)
    | OtherNumber x -> None
{{< /highlight >}}

Now, with the sample text, this can all be put together.

{{< highlight fsharp >}}
let sampleText =
    "467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598.."

sampleText.Split('\n')
|> extract
|> List.map asNumber
|> List.choose partNumberAsInt
|> List.sum
{{< /highlight >}}

```text
4361
```

`4361` is the correct answer with the sample input. <br />
My final answer is also correct. I get another gold star, and I can move on to part 2.


## Part 2 {#part-2}
